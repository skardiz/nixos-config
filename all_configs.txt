# ==============================================================================
# ФАЙЛ: ./home/alex/packages.nix
# ==============================================================================

# hm-modules/alex/packages.nix
{ pkgs, ... }:

{
  home.packages = with pkgs; [
    bash
    sops
    gnupg
    pinentry-curses
    anydesk
    #thorium-browser
  ];
}

# ==============================================================================
# ФАЙЛ: ./home/alex/default.nix
# ==============================================================================

# home/alex/default.nix
{ pkgs, config, ... }:
{
  imports = [
    ../_common # Импортируем ВСЕ общие настройки
    ./packages.nix
  ];

  # --- ИСПРАВЛЕНИЕ ЗДЕСЬ! ---
  # Алекс включает себе дополнительный набор пакетов для разработки
  my.home.packages = {
    dev = true;
  };
}

# ==============================================================================
# ФАЙЛ: ./home/mari/default.nix
# ==============================================================================

# home/mari/default.nix
{ pkgs, config, ... }:
{
  imports = [
    ../_common # Импортируем ВСЕ общие настройки
  ];
}

# ==============================================================================
# ФАЙЛ: ./home/_common/git.nix
# ==============================================================================

# home/_common/git.nix
# Этот модуль теперь использует хелпер из нашей кастомной библиотеки.
{ config, pkgs, mylib, ... }: # <-- Добавляем 'mylib' в аргументы

let
  # Вызываем наш новый, чистый хелпер из библиотеки.
  # Передаем ему имя текущего пользователя.
  gitSettings = mylib.myHelpers.getGitConfigForUser config.home.username;
in
{
  programs.git = {
    enable = true;
    # Применяем результат работы хелпера
    userName = gitSettings.userName;
    userEmail = gitSettings.userEmail;
  };
  services.ssh-agent.enable = true;
}

# ==============================================================================
# ФАЙЛ: ./home/_common/waydroid-idle.nix
# ==============================================================================

# home/_common/waydroid-idle.nix
# Этот модуль использует хелпер для генерации сложного скрипта.
{ pkgs, mylib, ... }: # <-- Добавляем 'mylib' в аргументы

let
  # Генерируем скрипт-сторож, вызывая наш новый хелпер.
  # Передаем ему 'pkgs', так как они нужны для создания скрипта.
  waydroid-idle-script = mylib.myHelpers.makeWaydroidIdleScript { inherit pkgs; };
in
{
  # Декларативно создаем и включаем наш пользовательский сервис-сторож.
  # Этот блок остается без изменений, но теперь он использует
  # результат работы нашего чистого хелпера.
  systemd.user.services.waydroid-idle-manager = {
    Unit = {
      Description = "WayDroid Idle Manager";
      After = [ "graphical-session.target" ];
    };
    Service = {
      ExecStart = "${waydroid-idle-script}/bin/waydroid-idle-manager";
      Restart = "always";
      RestartSec = 10;
    };
    Install = {
      WantedBy = [ "graphical-session.target" ];
    };
  };
}

# ==============================================================================
# ФАЙЛ: ./home/_common/options.nix
# ==============================================================================

# home/_common/options.nix
# "Пульт Управления" для всех пользовательских конфигураций.
{ lib, config, pkgs, ... }:
{
  options.my.home.packages = {
    common = lib.mkEnableOption "Базовый набор приложений (браузер, офис и т.д.)";
    dev = lib.mkEnableOption "Инструменты для разработки";
    # Здесь можно добавлять другие группы: 'gaming', 'design' и т.д.
  };

  config = {
    # Собираем все пакеты из включенных опций в один список
    home.packages = lib.mkMerge [
      (lib.mkIf config.my.home.packages.common [
        pkgs.google-chrome
        pkgs.libreoffice
        pkgs.obsidian
        pkgs.telegram-desktop
        pkgs.tree
        pkgs.zapzap
        pkgs.zoom-us
      ])
      (lib.mkIf config.my.home.packages.dev [
        pkgs.vscode
        pkgs.git-lfs
      ])
    ];
  };
}

# ==============================================================================
# ФАЙЛ: ./home/_common/default.nix
# ==============================================================================

# home/_common/default.nix
{ pkgs, ... }:
{
  imports = [
    # --- ИСПРАВЛЕНИЕ ЗДЕСЬ! ---
    # Подключаем наш новый "Пульт Управления"
    ./options.nix

    ./git.nix
    ./waydroid-idle.nix
  ];

  # Базовые настройки Home Manager (без изменений)
  nixpkgs.config.allowUnfree = true;
  home.stateVersion = "25.11";

  # --- ИСПРАВЛЕНИЕ ЗДЕСЬ! ---
  # Убираем жестко закодированный список пакетов
  # home.packages = [ ... ];

  # Декларативно включаем наборы пакетов, общие для всех пользователей
  my.home.packages = {
    common = true; # Включаем базовый набор для всех
  };
}

# ==============================================================================
# ФАЙЛ: ./home/_common/packages.nix
# ==============================================================================

# home/_common/packages.nix
#
# Этот модуль отвечает за управление пакетами для пользователей.
# Он читает "пульт управления" и добавляет нужные пакеты.
{ lib, config, pkgs, ... }:

{
  # Мы определяем здесь ТОЛЬКО конфигурацию, не опции.
  # Опции уже определены в нашем центральном `modules/options.nix`.
  config = {
    # Собираем все пакеты из включенных опций в один список
    home.packages = lib.mkMerge [
      # lib.mkIf <условие> [ <список пакетов> ]
      (lib.mkIf config.my.home.packages.common [
        pkgs.google-chrome
        pkgs.libreoffice
        pkgs.obsidian
        pkgs.telegram-desktop
        pkgs.tree
        pkgs.zapzap
        pkgs.zoom-us
      ])
      (lib.mkIf config.my.home.packages.dev [
        pkgs.vscode
        pkgs.git-lfs
      ])
    ];
  };
}

# ==============================================================================
# ФАЙЛ: ./hosts/shershulya/hardware-configuration.nix
# ==============================================================================

# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

{
  imports =
    [ (modulesPath + "/installer/scan/not-detected.nix")
    ];

  boot.initrd.availableKernelModules = [ "xhci_pci" "ahci" "nvme" "usbhid" "usb_storage" "sd_mod" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-intel" ];
  boot.extraModulePackages = [ ];

  fileSystems."/" =
    { device = "/dev/disk/by-uuid/85de1e10-4038-408b-a4a3-b8da3cd8f18b";
      fsType = "btrfs";
      options = [ "subvol=root" ];
    };

  fileSystems."/home" =
    { device = "/dev/disk/by-uuid/85de1e10-4038-408b-a4a3-b8da3cd8f18b";
      fsType = "btrfs";
      options = [ "subvol=home" ];
    };

  fileSystems."/nix" =
    { device = "/dev/disk/by-uuid/85de1e10-4038-408b-a4a3-b8da3cd8f18b";
      fsType = "btrfs";
      options = [ "subvol=nix" ];
    };

  fileSystems."/var/log" =
    { device = "/dev/disk/by-uuid/85de1e10-4038-408b-a4a3-b8da3cd8f18b";
      fsType = "btrfs";
      options = [ "subvol=log" ];
    };

  fileSystems."/persist" =
    { device = "/dev/disk/by-uuid/85de1e10-4038-408b-a4a3-b8da3cd8f18b";
      fsType = "btrfs";
      options = [ "subvol=persist" ];
    };

  fileSystems."/snapshots" =
    { device = "/dev/disk/by-uuid/85de1e10-4038-408b-a4a3-b8da3cd8f18b";
      fsType = "btrfs";
      options = [ "subvol=snapshots" ];
    };

  fileSystems."/var/cache" =
    { device = "/dev/disk/by-uuid/85de1e10-4038-408b-a4a3-b8da3cd8f18b";
      fsType = "btrfs";
      options = [ "subvol=cache" ];
    };

  fileSystems."/tmp" =
    { device = "/dev/disk/by-uuid/85de1e10-4038-408b-a4a3-b8da3cd8f18b";
      fsType = "btrfs";
      options = [ "subvol=tmp" ];
    };

  fileSystems."/games" =
    { device = "/dev/disk/by-uuid/85de1e10-4038-408b-a4a3-b8da3cd8f18b";
      fsType = "btrfs";
      options = [ "subvol=games" ];
    };

  fileSystems."/boot" =
    { device = "/dev/disk/by-uuid/9B9A-4548";
      fsType = "vfat";
      options = [ "fmask=0022" "dmask=0022" ];
    };

  swapDevices = [ ];

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;
  # networking.interfaces.enp0s31f6.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}

# ==============================================================================
# ФАЙЛ: ./hosts/shershulya/default.nix
# ==============================================================================

# ./hosts/shershulya/default.nix
#
# Финальная, единственно правильная версия от Дедушки-Кузнеца
{ config, pkgs, inputs, lib, ... }:

{
  imports = [
    ./hardware-configuration.nix
    ../../modules/roles/desktop.nix
    ../../modules/roles/developer.nix
    ../../modules/hardware/nvidia-pascal.nix
    ../../modules/hardware/intel-cpu.nix
    ../../modules/features/vpn.nix
  ];

  sops = {
    age.keyFile = "/etc/sops/keys/sops.key";
    defaultSopsFile = ../../secrets.yaml; # Для удобства можно указать файл по умолчанию
    secrets = {
      vpn_private_key = {}; # sops сам найдет его в defaultSopsFile
      github_token = {
        # --- ВОТ ОНО, ИСТИННОЕ ЛЕКАРСТВО ---
        # Эта строка говорит: "Этот секрет нужен пользователям.
        # Подготовь его ДО активации Home Manager".
        # Это разрывает цикл зависимости.
        neededForUsers = true;
      };
    };
  };

  # Эта настройка остается. Она правильная.
  nix.settings.access-tokens = "github.com=${config.sops.secrets.github_token.path}";

  networking.hostName = "shershulya";
  system.stateVersion = "25.11";

  my.users.accounts = {
    alex = { isMainUser = true; description = "Alex"; extraGroups = [ "adbusers" ]; };
    mari = { description = "Mari"; };
  };
}

# ==============================================================================
# ФАЙЛ: ./hosts/shershulya/flake.nix
# ==============================================================================

# hosts/shershulya/flake.nix
#
# Местный закон для Крепости "shershulya"
{ inputs, ... }: {
  # Указываем, какую операционную систему мы строим
  system = "x86_64-linux";

  # Главное: перечисляем, кто из граждан живет в этой Крепости
  users = [ "alex" "mari" ];

  # Указываем, какие системные модули использовать для этой Крепости
  modules = [
    # --- ВОТ ОНО, ИСТИННОЕ ЛЕКАРСТВО ---
    # Мы приказываем: "Прежде чем строить что-либо,
    # сначала прочти наш общий, фундаментальный свод законов и определений".
    ../../modules/system

    # А уже потом - все остальное
    ./default.nix
    inputs.home-manager.nixosModules.home-manager
  ];
}

# ==============================================================================
# ФАЙЛ: ./modules/hardware/nvidia-pascal.nix
# ==============================================================================

# /home/alex/nixos-config/modules/nvidia.nix
{ config, pkgs, lib, ... }:

{
  # Параметры ядра для корректной работы NVIDIA на Wayland
  boot.kernelParams = [ "nvidia-drm.modeset=1" "nvidia_drm.fbdev=1" "nvidia.NVreg_EnableGpuFirmware=0" ];

  # Новые опции для графики (замена hardware.opengl)
  hardware.graphics = {
    enable = true;
    enable32Bit = true;
    extraPackages = with pkgs; [
      # Пакеты для аппаратного ускорения видео
      nvidia-vaapi-driver
      libvdpau-va-gl
    ];
  };

  hardware.nvidia = {
    modesetting.enable = true;
    powerManagement.enable = true;
    powerManagement.finegrained = false;
    open = false;
    nvidiaSettings = true;
    package = config.boot.kernelPackages.nvidiaPackages.beta;
    forceFullCompositionPipeline = true;
  };

  services.xserver.videoDrivers = [ "nvidia" ];

  # Переменные окружения для Wayland
  environment.sessionVariables = {
    LIBVA_DRIVER_NAME = "nvidia";
    XDG_SESSION_TYPE = "wayland";
    GBM_BACKEND = "nvidia-drm";
    __GLX_VENDOR_LIBRARY_NAME = "nvidia";
    WLR_NO_HARDWARE_CURSORS = "1";
    NIXOS_OZONE_WL = "1";
  };

  # Дополнительные системные пакеты (с исправленными именами)
  environment.systemPackages = with pkgs; [
  ];
}

# ==============================================================================
# ФАЙЛ: ./modules/hardware/intel-cpu.nix
# ==============================================================================

# modules/hardware/intel-cpu.nix
#
# Этот модуль применяет общие оптимизации для процессоров Intel
# из репозитория nixos-hardware.
{ inputs, ... }:
{
  imports = [
    # Указываем путь к модулю внутри нашего нового 'inputs.hardware'
    inputs.hardware.nixosModules.common-cpu-intel
  ];
}

# ==============================================================================
# ФАЙЛ: ./modules/features/gaming.nix
# ==============================================================================

# modules/features/gaming.nix
{ pkgs, ... }:
{
  environment.sessionVariables = { MANGOHUD = "1"; };
  programs.steam = {
    enable = true;
    extraCompatPackages = [ pkgs.proton-ge-bin ];
  };
  programs.gamemode.enable = true;
  environment.systemPackages = with pkgs; [ gamescope ];
}

# ==============================================================================
# ФАЙЛ: ./modules/features/vpn.nix
# ==============================================================================

# modules/features/vpn.nix

# Финальный, рабочий указ, исправленный мудростью Императора.
{ config, pkgs, ... }:

{
  # --- Шаг 1: Сборка модуля (остается) ---
  # Этот указ, как вы и сказали, был верным.
  boot.extraModulePackages = [ config.boot.kernelPackages.amneziawg ];

  # --- ВОТ ОНО, ИСТИННОЕ ЛЕКАРСТВО ---
  # Этот указ говорит: "Не просто построй эту деталь.
  # ЯВНО ВКРУТИ ее в двигатель при каждом запуске Королевства!".
  boot.kernelModules = [ "amneziawg" ];

  # ... остальная часть файла (утилиты, сервис, sops) остается без изменений ...
  environment.systemPackages = with pkgs; [
    amnezia-vpn
    amneziawg-tools
    amneziawg-go
  ];

  # Если ты используешь sops, эта секция должна быть в твоем главном конфиге,
  # а не здесь. Я лишь напоминаю о ее структуре.
  # sops.secrets.vpn_private_key.owner = "root";

  systemd.services.amnezia-vpn = {
    description = "AmneziaWG auto-connect service";
    after = [ "network-online.target" "sops-nix.service" ];
    wants = [ "network-online.target" ];
    wantedBy = [ "multi-user.target" ];
    script = ''
      CONF_FILE="/run/amnezia-vpn/awg0.conf"
      mkdir -p "$(dirname "$CONF_FILE")"
      chmod 700 "$(dirname "$CONF_FILE")" # Защищаем папку
      PRIVATE_KEY=$(cat "${config.sops.secrets.vpn_private_key.path}")

      cat > "$CONF_FILE" << EOF
[Interface]
PrivateKey = $PRIVATE_KEY
Address = 10.8.0.4/24
DNS = 1.1.1.1
Jc = 9
Jmin = 50
Jmax = 1000
S1 = 100
S2 = 75
H1 = 1583110509
H2 = 1884699694
H3 = 538034460
H4 = 1051564253

[Peer]
PublicKey = wNeK1oGyI7fVtLMI4lzFKllowEvuw72VV/F4k/uX9xk=
PresharedKey = PFLFbHnr1Wuctm6JuSukg73/xxHohmNZ3IPsYvKpImY=
AllowedIPs = 0.0.0.0/0, ::/0
PersistentKeepalive = 0
Endpoint = 185.125.200.148:51820
EOF

      chmod 600 "$CONF_FILE" # Защищаем сам конфиг

      ${pkgs.amneziawg-tools}/bin/awg-quick up "$CONF_FILE"
    '';
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStop = "${pkgs.amneziawg-tools}/bin/awg-quick down awg0";
    };
  };
}

# ==============================================================================
# ФАЙЛ: ./modules/features/android.nix
# ==============================================================================

# modules/features/android.nix
#
# Здесь мы разрываем порочный круг бесконечной рекурсии.
{ pkgs, ... }: # Убрали 'config' и 'lib', они здесь больше не нужны

{
  # Мы оставляем Waydroid выключенным по умолчанию. Это правильная стратегия.
  virtualisation.waydroid.enable = false;

  # Твои настройки для утилит остаются.
  environment.systemPackages = with pkgs; [
    wl-clipboard
    xorg.xwininfo
    xorg.xprop
  ];

  # --- ВОТ ОНО, ИСТИННОЕ ЛЕКАРСТВО ---
  # Мы больше не спрашиваем у системы, где находится твой дом.
  # Мы говорим ей это прямо. Мы жестко прописываем путь.
  fileSystems."/var/lib/waydroid/data/media/0/Shared" = {
    device = "/home/alex/Shared/waydroid"; # <-- ХИРУРГИЧЕСКИЙ РАЗРЕЗ
    fsType = "none";
    options = [ "bind" ];
  };
  # --- КОНЕЦ ЛЕКАРСТВА ---
}

# ==============================================================================
# ФАЙЛ: ./modules/features/docker.nix
# ==============================================================================

# modules/features/docker.nix
#
# Эта фича отвечает за включение и настройку Docker.
{ lib, config, ... }:

{
  # Включаем сам Docker
  virtualisation.docker.enable = true;

  # Даем всем пользователям, определенным в нашей системе,
  # доступ к сокету Docker. Это элегантный способ, не требующий
  # ручного добавления каждого пользователя.
  users.extraGroups.docker.members = lib.mapAttrsToList (name: value: name) config.my.users.accounts;

  # Раскомментируй следующую строку, если твоя файловая система - BTRFS
  virtualisation.docker.storageDriver = "btrfs";
}

# ==============================================================================
# ФАЙЛ: ./modules/features/devops.nix
# ==============================================================================

# modules/features/devops.nix
#
# Эта фича отвечает за установку инструментов для DevOps:
# Kubernetes, Docker Compose и т.д.
{ pkgs, ... }:

{
  # Просто добавляем нужные пакеты в системные пути.
  # NixOS сама скачает, соберет и установит их.
  environment.systemPackages = with pkgs; [
    # Инструменты для Kubernetes
    minikube
    kubectl

    # Инструменты для Docker (docker-compose уже часть пакета docker,
    # но можно явно указать, если нужна конкретная версия)
    # docker-compose
  ];
}

# ==============================================================================
# ФАЙЛ: ./modules/features/nix-index.nix
# ==============================================================================

# modules/features/nix-index.nix
# Включает nix-index и использует готовую базу данных от сообщества
# для экономии времени и ресурсов.
{ pkgs, ... }:

{
  programs.nix-index = {
    enable = true;
    # Используем готовую базу данных
    enableZshIntegration = true; # Если используешь Zsh
    package = pkgs.nix-index;
  };

  # Добавляем сервис, который будет автоматически скачивать базу
  systemd.services.nix-index = {
    serviceConfig.ExecStart = ''
      ${pkgs.nix-index}/bin/nix-index --build-database-from-url https://github.com/Mic92/nix-index-database/releases/download/master/files
    '';
  };
}

# ==============================================================================
# ФАЙЛ: ./modules/features/filebrowser.nix
# ==============================================================================

# modules/features/filebrowser.nix
#
# Здесь мы исправляем грамматическую ошибку самозванца.
{ pkgs, ... }:

}

# ==============================================================================
# ФАЙЛ: ./modules/features/desktop.nix
# ==============================================================================

# modules/features/desktop.nix
#
# Этот модуль реализует все, что нужно для базового десктопа.
{ pkgs, ... }:
{
  networking.networkmanager.enable = true;
  # Включаем системную службу DNS, необходимую для NetworkManager
  services.resolved.enable = true;

  services.xserver.enable = true;
  services.xserver.xkb = { layout = "us,ru"; options = "grp:alt_shift_toggle"; };
  services.displayManager.sddm.enable = true;
  services.desktopManager.plasma6.enable = true;
  services.pipewire = {
    enable = true;
    alsa.enable = true;
    alsa.support32Bit = true;
    pulse.enable = true;
  };
}

# ==============================================================================
# ФАЙЛ: ./modules/roles/desktop.nix
# ==============================================================================

# modules/profiles/desktop.nix
#
# Это универсальный профиль ("набор LEGO") для любого вашего "основного десктопа".
# --- ИСПРАВЛЕНИЕ ЗДЕСЬ! ---
# Мы превращаем этот файл в функцию, которая принимает 'pkgs' в качестве аргумента.
{ pkgs, ... }:

{
  imports = [
    # Подключаем "кирпичики"-фичи
    ../features/desktop.nix
    ../features/gaming.nix
    ../features/android.nix
    ../features/docker.nix
  ];

  # Определяем стандарт загрузки для всех наших десктопов
  boot = {
    loader.systemd-boot.enable = true;
    loader.efi.canTouchEfiVariables = true;
    loader.timeout = 0;

    # Теперь 'pkgs' здесь известен, и эта строка будет работать
    kernelPackages = pkgs.linuxPackages_zen;
  };

  # Настройки по умолчанию для этого профиля
  my = {
    locale.enableRussian = true;
    optimizations = {
      enableSsdTweaks = true;
      enableZlibNg = true;
      enableDesktopResponsiveness = true;
    };
  };
}

# ==============================================================================
# ФАЙЛ: ./modules/roles/developer.nix
# ==============================================================================

# modules/roles/developer.nix
#
# Эта роль объединяет все фичи, необходимые для универсальной
# среды разработки и DevOps. Это - наша "Кузница".
{ pkgs, ... }:

{
  imports = [
    # Включаем порт Docker, чтобы он был доступен
    ../features/docker.nix

    # Включаем инструменты Адмирала Kubernetes
    ../features/devops.nix # <-- devops - это фича, а не роль

    # Здесь можно добавить другие универсальные фичи
    # Например, ../features/vscode.nix или ../features/git-tools.nix
  ];

  # Здесь можно добавить опции, специфичные для этой роли
  # Например, разблокировать некоторые системные лимиты для разработки
}

# ==============================================================================
# ФАЙЛ: ./modules/system/sops.nix
# ==============================================================================

# modules/system/sops.nix
{ inputs, ... }:

{
  imports = [
    inputs.sops-nix.nixosModules.sops
  ];
}

# ==============================================================================
# ФАЙЛ: ./modules/system/nix.nix
# ==============================================================================

# modules/system/nix.nix
# Финальная, единственно правильная версия
{ pkgs, lib, ... }:

{

  # --- ПРИКАЗЫ АРХИТЕКТОРУ-ДЕКОРАТОРУ (ОСТАЮТСЯ В СИЛЕ) ---
  nix.extraOptions = ''
    experimental-features = nix-command flakes
  '';

  nix.settings = {
    experimental-features = [ "nix-command" "flakes" ];
    extra-substituters = [
      "https://cache.nixos.org"
      "https://nix-community.cachix.org"
    ];
    extra-trusted-public-keys = [
      "cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY="
      "nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs="
    ];
  };

}

# ==============================================================================
# ФАЙЛ: ./modules/system/options.nix
# ==============================================================================

# modules/system/options.nix
#
# ТВОЙ НАСТОЯЩИЙ, РАБОТАЮЩИЙ ПУЛЬТ УПРАВЛЕНИЯ,
# в который мы аккуратно добавили новую опцию.
{ lib, config, pkgs, ... }:

# =================================================================
# РАЗДЕЛ 1: "ПАНЕЛЬ УПРАВЛЕНИЯ" (options.my)
# =================================================================
{
  options.my = {
    locale.enableRussian = lib.mkEnableOption "Полная русификация системы";

    optimizations = {
      enableSsdTweaks = lib.mkEnableOption "Оптимизации для SSD (fstrim)";
      enableZlibNg = lib.mkEnableOption "Высокопроизводительная библиотека zlib-ng";
      enableDesktopResponsiveness = lib.mkEnableOption "Службы для отзывчивости десктопа";

      # --- ВОТ ОНА, НАША НОВАЯ ЛЮСТРА (КНОПКА) ---
      enableSwap = lib.mkEnableOption "Декларативный swap-файл для стабильности системы.";
    };

    policies = {
      allowUnfree = lib.mkEnableOption "Разрешить несвободные пакеты";
      enableAutoGc = lib.mkEnableOption "Автоматическая сборка мусора";
      enableFlakes = lib.mkEnableOption "Включить Flakes и nix-command";
    };

    services.enableCore = lib.mkEnableOption "Включить базовый набор системных сервисов и утилит";
  };

# =================================================================
# РАЗДЕЛ 2: "МАШИННОЕ ОТДЕЛЕНИЕ" (config)
# =================================================================
  config = lib.mkMerge [
    # --- Блок 1: Твои индивидуальные настройки ---
    {
      time.timeZone = lib.mkIf config.my.locale.enableRussian "Europe/Moscow";
      i18n.defaultLocale = lib.mkIf config.my.locale.enableRussian "ru_RU.UTF-8";
      console.keyMap = lib.mkIf config.my.locale.enableRussian "ru";

      services.fstrim.enable = lib.mkIf config.my.optimizations.enableSsdTweaks true;
      nixpkgs.config.zlib.package = lib.mkIf config.my.optimizations.enableZlibNg pkgs.zlib-ng;
      security.rtkit.enable = lib.mkIf config.my.optimizations.enableDesktopResponsiveness true;
      services.irqbalance.enable = lib.mkIf config.my.optimizations.enableDesktopResponsiveness true;
      services.ananicy.enable = lib.mkIf config.my.optimizations.enableDesktopResponsiveness true;

      nixpkgs.config.allowUnfree = lib.mkIf config.my.policies.allowUnfree true;
      nix.gc = lib.mkIf config.my.policies.enableAutoGc {
        automatic = true;
        dates = "weekly";
        options = "--delete-older-than 7d";
      };
      nix.optimise.automatic = lib.mkIf config.my.policies.enableAutoGc true;
      nix.settings.experimental-features = lib.mkIf config.my.policies.enableFlakes [ "nix-command" "flakes" ];
    }

    # --- Блок 2: Твой "Базовый Пакет Коммунальных Услуг" ---
    (lib.mkIf config.my.services.enableCore {
      services.timesyncd.enable = true;
      networking.firewall.enable = true;
      environment.systemPackages = [
        pkgs.git
        pkgs.nix-index
      ];
      programs.nix-index.enable = true;
      programs.command-not-found.enable = false;
    })

    # --- Блок 3: НАШ НОВЫЙ МЕХАНИЗМ ДЛЯ ЛЮСТРЫ ---
    (lib.mkIf config.my.optimizations.enableSwap {
      swapDevices = [{
        device = "/var/lib/swapfile";
        size = 16 * 1024; # 16 GB
      }];
      boot.kernel.sysctl = {
        "vm.swappiness" = 10;
      };
    })
  ];
}


# ==============================================================================
# ФАЙЛ: ./modules/system/users.nix
# ==============================================================================

# modules/users.nix
#
# Наш собственный, высокоуровневый модуль для управления пользователями.
{ lib, config, self, inputs, mylib, ... }: # <-- Добавляем 'mylib' в аргументы

let
  cfg = config.my.users;
in
{
  # --- Объявляем наш API для пользователей ---
  options.my.users.accounts = lib.mkOption {
    type = with lib.types; attrsOf (submodule {
      options = {
        isMainUser = lib.mkEnableOption "Этот пользователь является основным (для автологина)";
        description = lib.mkOption {
          type = str;
          default = "";
          description = "Полное имя пользователя.";
        };
        extraGroups = lib.mkOption {
          type = listOf str;
          default = [];
          description = "Дополнительные группы для пользователя.";
        };
      };
    });
    default = {};
    description = "Декларативное описание всех пользователей в системе.";
  };

  # --- Генерируем конфигурацию на основе нашего API ---
  config = {
    # 1. Генерируем блок users.users
    users.users = lib.mapAttrs
      (name: userCfg: {
        isNormalUser = true;
        description = userCfg.description;
        extraGroups = [ "wheel" "networkmanager" "video" ] ++ userCfg.extraGroups;
      })
      cfg.accounts;

    # 2. Генерируем блок home-manager.users
    home-manager.users = lib.mapAttrs
      (name: _:
        # Мы строим "чистый" путь от корня проекта, используя 'self'.
        import "${self}/home/${name}"
      )
      cfg.accounts;

    # --- ИСПРАВЛЕНИЕ ЗДЕСЬ! ---
    # 3. Передаем ВСЕ необходимые аргументы в модули Home Manager.
    # Раньше здесь не было 'mylib' и 'self'.
    home-manager.extraSpecialArgs = { inherit inputs self mylib; };

    # 4. Генерируем блок автологина для основного пользователя
    services.displayManager.autoLogin =
      let
        mainUsers = lib.filterAttrs (name: userCfg: userCfg.isMainUser) cfg.accounts;
        mainUserName = lib.head (lib.attrNames mainUsers);
      in
      lib.mkIf (mainUsers != {}) {
        enable = true;
        user = mainUserName;
      };
  };
}

# ==============================================================================
# ФАЙЛ: ./modules/system/default.nix
# ==============================================================================

# modules/system/default.nix
#
# Это центральный "хаб" для ВСЕХ системных настроек.
# Фундамент для любого хоста в нашей конфигурации.
{ pkgs, inputs, ... }:

{
  imports = [
    # Фундаментальные настройки Nix
    ./nix.nix

    # Возможность использовать Sops
    ./sops.nix

    # Наши собственные базовые опции (бывший core/options.nix)
    ./options.nix

    # Наш API для управления пользователями (бывший core/users.nix)
    ./users.nix
  ];

  # Твои глобальные политики
  my = {
    policies = {
      allowUnfree = true;
      enableAutoGc = true;
      enableFlakes = true;
    };
    services.enableCore = true;
  };
}

# ==============================================================================
# ФАЙЛ: ./modules/system/swap.nix
# ==============================================================================

# modules/system/swap.nix
#
# Этот модуль отвечает за создание декларативного swap-файла.
# Наш "бездонный колодец" на случай нехватки RAM.
{ lib, ... }:

{
  # Создаем swap-устройство. В нашем случае - это файл.
  swapDevices = [{
    # Путь, где будет лежать наш файл. /var/lib - стандартное место.
    device = "/var/lib/swapfile";

    # Размер в мегабайтах.
    # Хорошее правило: если у тебя 8ГБ RAM, сделай 8ГБ (8 * 1024)
    # или даже 16ГБ (16 * 1024) swap.
    # Давай сделаем 16ГБ для уверенности.
    size = 16 * 1024;
  }];

  # Дополнительная настройка: swappiness.
  # Говорит ядру, насколько агрессивно использовать swap.
  # Значение 10 - хороший компромисс: "старайся не использовать,
  # но если RAM кончается - не стесняйся".
  boot.kernel.sysctl = {
    "vm.swappiness" = 10;
  };
}

# ==============================================================================
# ФАЙЛ: ./lib/default.nix
# ==============================================================================

# lib/default.nix
# Наша библиотека кастомных вспомогательных функций.
{ lib, pkgs, ... }:

{
  myHelpers = {
    # --- Инструмент №1: Получение настроек Git (без изменений) ---
    getGitConfigForUser = userName:
      let
        userMap = {
          alex = { userName = "Alex"; userEmail = "skardizone@gmail.com"; };
        };
        defaultUser = { userName = "NixOS User"; userEmail = "user@localhost"; };
      in
      userMap.${userName} or defaultUser;

    # --- Инструмент №2: Генератор скрипта Waydroid (Улучшенный) ---
    makeWaydroidIdleScript = { pkgs }:
      pkgs.writeShellScriptBin "waydroid-idle-manager" ''
        #!${pkgs.bash}/bin/bash
        TIMEOUT_SECONDS=300
        last_seen_timestamp=0

        # Функция для проверки, открыты ли окна Waydroid
        are_waydroid_windows_open() {
          local window_ids=$(${pkgs.xorg.xwininfo}/bin/xwininfo -root -children | grep "^\s\+0x" | awk '{print $1}')
          for id in $window_ids; do
            if ${pkgs.xorg.xprop}/bin/xprop -id "$id" WM_CLASS | grep -q "waydroid"; then
              return 0 # 0 означает "да, открыты"
            fi
          done
          return 1 # 1 означает "нет, не открыты"
        }

        echo "WayDroid Idle Manager запущен для пользователя $USER."
        while true; do
          if are_waydroid_windows_open; then
            last_seen_timestamp=$(date +%s)
          else
            if [[ $last_seen_timestamp -ne 0 ]]; then
              current_time=$(date +%s)
              elapsed=$((current_time - last_seen_timestamp))
              if [[ $elapsed -gt $TIMEOUT_SECONDS ]]; then
                echo "Таймаут ($TIMEOUT_SECONDS сек) достигнут. Остановка WayDroid..."
                ${pkgs.waydroid}/bin/waydroid session stop
                # --- ИСПРАВЛЕНИЕ ЗДЕСЬ! ---
                # Вместо 'sudo systemctl stop ...' мы отправляем сообщение по D-Bus.
                ${pkgs.glib}/bin/gdbus call --system --dest org.waydroid.container \
                  --object-path /org/freedesktop/systemd1 \
                  --method org.freedesktop.systemd1.Manager.StopUnit "waydroid-container.service" "replace"
                echo "WayDroid остановлен."
                last_seen_timestamp=0
              fi
            fi
          fi
          sleep 10
        done
      '';
  };
}

# ==============================================================================
# ФАЙЛ: ./flake.nix
# ==============================================================================

# flake.nix (НОВАЯ, ЧИСТАЯ ВЕРСИЯ)
{
  description = "Моя декларативная Империя";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    hardware.url = "github:NixOS/nixos-hardware/master";
    home-manager = {
      url = "github:nix-community/home-manager";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    sops-nix = {
      url = "github:Mic92/sops-nix";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  # Мы выносим всю логику в отдельный файл, чтобы здесь была чистота
  outputs = inputs: import ./outputs.nix inputs;
}

# ==============================================================================
# ФАЙЛ: ./outputs.nix
# ==============================================================================

# outputs.nix
#
# Министерство Юстиции, которое уважает папку 'home'.
{ self, nixpkgs, home-manager, ... }@inputs:

let
  # Твоя существующая библиотека
  mylib = import ./lib { lib = nixpkgs.lib; pkgs = nixpkgs.legacyPackages."x86_64-linux"; };

  # Функция, которая находит все папки в директории 'hosts'
  # и считает их нашими Крепостями.
  discoverHosts = builtins.readDir ./hosts;

  # Собираем все конфигурации систем
  nixosSystems = builtins.listToAttrs (map (hostName: {
    name = hostName;
    value = let
      hostFlake = import ./hosts/${hostName}/flake.nix { inherit inputs; };
    in nixpkgs.lib.nixosSystem {
      system = hostFlake.system;
      specialArgs = { inherit inputs self mylib; };
      modules = hostFlake.modules;
    };
  }) (builtins.attrNames discoverHosts));

  # Собираем все конфигурации пользователей
  homeConfigurations = builtins.listToAttrs (builtins.concatLists (map (hostName: let
    hostFlake = import ./hosts/${hostName}/flake.nix { inherit inputs; };
  in map (userName: {
    name = "${userName}@${hostName}";
    value = home-manager.lib.homeManagerConfiguration {
      pkgs = nixpkgs.legacyPackages.${hostFlake.system};
      extraSpecialArgs = { inherit inputs self mylib; };
      # --- ВОТ ОНО, ИСПРАВЛЕНИЕ С УВАЖЕНИЕМ ---
      # Мы смотрим в твою правильную папку 'home'.
      modules = [ ./home/${userName} ];
    };
  }) hostFlake.users) (builtins.attrNames discoverHosts)));

in
{
  # Отдаем финальный результат
  nixosConfigurations = nixosSystems;
  homeConfigurations = homeConfigurations;
}
